// Generated by Apple Swift version 3.1 (swiftlang-802.0.53 clang-802.0.42)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if defined(__has_include) && __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if defined(__has_attribute) && __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if defined(__has_attribute) && __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
# if defined(__has_feature) && __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if defined(__has_feature) && __has_feature(modules)
@import ObjectiveC;
@import UIKit;
@import CoreGraphics;
@import CoreLocation;
@import Foundation;
@import AVFoundation;
@import MapKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
@class CLLocation;
@class ARAnnotationView;

/// Serves as the source of information(location, title etc.) about a single annotation. Annotation objects do not provide
/// the visual representation of the annotation. It is analogue to MKAnnotation. It can be subclassed if additional
/// information for some annotation is needed.
SWIFT_CLASS("_TtC18HDAugmentedReality12ARAnnotation")
@interface ARAnnotation : NSObject
/// Identifier of annotation, not used by HDAugmentedReality internally.
@property (nonatomic, copy) NSString * _Nullable identifier;
/// Title of annotation, can be used in ARAnnotationView
@property (nonatomic, copy) NSString * _Nullable title;
/// Location of the annotation, it is guaranteed to be valid location(coordinate). It is set in init or by validateAndSetLocation.
@property (nonatomic, readonly, strong) CLLocation * _Nonnull location;
/// View for annotation. It is set inside ARPresenter after fetching view from dataSource.
@property (nonatomic, readonly, strong) ARAnnotationView * _Nullable annotationView;
@property (nonatomic, readonly) double distanceFromUser;
@property (nonatomic, readonly) double azimuth;
@property (nonatomic, readonly) BOOL active;
/// Returns annotation if location(coordinate) is valid.
- (nullable instancetype)initWithIdentifier:(NSString * _Nullable)identifier title:(NSString * _Nullable)title location:(CLLocation * _Nonnull)location OBJC_DESIGNATED_INITIALIZER;
/// Validates location.coordinate and sets it.
- (BOOL)validateAndSetLocationWithLocation:(CLLocation * _Nonnull)location SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

@class NSCoder;

/// Responsible for presenting annotations visually. Analogue to MKAnnotationView.
/// It is usually subclassed to provide custom look.
/// Annotation views should be lightweight, try to avoid xibs and autolayout.
SWIFT_CLASS("_TtC18HDAugmentedReality16ARAnnotationView")
@interface ARAnnotationView : UIView
/// \code
/// Normally, center of annotationView points to real location of POI, but this property can be used to alter that.
/// E.g. if bottom-left edge of annotationView should point to real location, centerOffset should be (0, 1)
///
/// \endcode
@property (nonatomic) CGPoint centerOffset;
@property (nonatomic, weak) ARAnnotation * _Nullable annotation;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
- (void)awakeFromNib;
/// Will always be called once, no need to call super
- (void)initialize;
/// Called when distance/azimuth changes, intended to be used in subclasses
- (void)bindUi;
@end

@class ARViewController;

/// DataSource provides the ARViewController with the information needed to display annotations.
SWIFT_PROTOCOL("_TtP18HDAugmentedReality12ARDataSource_")
@protocol ARDataSource <NSObject>
/// Asks the data source to provide annotation view for annotation. Annotation view must be subclass of ARAnnotationView.
- (ARAnnotationView * _Nonnull)ar:(ARViewController * _Nonnull)arViewController viewForAnnotation:(ARAnnotation * _Nonnull)viewForAnnotation SWIFT_WARN_UNUSED_RESULT;
@optional
/// READ BEFORE IMPLEMENTING
/// ARViewController tracks user movement and shows/hides annotations accordingly. But if there is huge amount
/// of annotations or for some other reason annotations cannot be set all at once, this method can be used to
/// set annotations part by part.
/// Use ARViewController.trackingManager.reloadDistanceFilter to change how often this is called.
/// \param arViewController ARViewController instance
///
/// \param location Current location of the user
///
///
/// returns:
/// Annotations to load, previous annotations are removed
- (NSArray<ARAnnotation *> * _Nonnull)ar:(ARViewController * _Nonnull)arViewController shouldReloadWithLocation:(CLLocation * _Nonnull)location SWIFT_WARN_UNUSED_RESULT;
@end


/// Adds ARAnnotationViews on the screen and calculates its screen positions. Before anything
/// is done, it first filters annotations by distance and count for improved performance. This
/// class is also responsible for vertical stacking of the annotation views.
/// It can be subclassed if custom positioning is needed, e.g. if you wan’t to position
/// annotations relative to its altitudes you would subclass ARPresenter and override
/// xPositionForAnnotationView and yPositionForAnnotationView.
SWIFT_CLASS("_TtC18HDAugmentedReality11ARPresenter")
@interface ARPresenter : UIView
/// Stacks overlapping annotations vertically.
@property (nonatomic) BOOL verticalStackingEnabled;
/// All annotations farther(from user) than this value will be offset using distanceOffsetMultiplier. Use it if distanceOffsetMode is manual.
/// Also look at distanceOffsetMultiplier and distanceOffsetMode.
@property (nonatomic) double distanceOffsetMinThreshold;
/// If set, it will be used instead of distanceOffsetMultiplier and distanceOffsetMinThreshold if distanceOffsetMode != none
/// Use it to calculate vartical offset by given distance.
@property (nonatomic, copy) double (^ _Nullable distanceOffsetFunction)(double);
/// How low on the screen is nearest annotation. 0 = top, 1  = bottom.
@property (nonatomic) double bottomBorder;
@property (nonatomic, weak) ARViewController * _Null_unspecified arViewController;
@property (nonatomic, copy) NSArray<ARAnnotation *> * _Nonnull annotations;
@property (nonatomic, copy) NSArray<ARAnnotation *> * _Nonnull activeAnnotations;
@property (nonatomic, copy) NSArray<ARAnnotationView *> * _Nonnull annotationViews;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// Total maximum number of visible annotation views. Default value is 100. Max value is 500.
/// This will affect performance, especially if verticalStackingEnabled.
@property (nonatomic) NSInteger maxVisibleAnnotations;
/// Maximum distance(in meters) for annotation to be shown.
/// Default value is 0 meters, which means that distances of annotations don’t affect their visiblity.
/// This can be used to increase performance.
@property (nonatomic) double maxDistance;
/// Gives opportunity to the presenter to filter annotations and reduce number of items it is working with.
/// Default implementation filters by maxVisibleAnnotations and maxDistance.
- (NSArray<ARAnnotation *> * _Nonnull)activeAnnotationsFromAnnotationsWithAnnotations:(NSArray<ARAnnotation *> * _Nonnull)annotations SWIFT_WARN_UNUSED_RESULT;
/// Creates views for active annotations and removes views from inactive annotations.
/// @IMPROVEMENT: Add reuse logic
- (void)createAnnotationViews;
/// Removes all annotation views from screen and resets annotations
- (void)clear;
- (void)adjustVerticalOffsetParameters;
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end


@interface ARPresenter (SWIFT_EXTENSION(HDAugmentedReality))
/// Stacks annotationViews vertically if they are overlapping. This works by comparing frames of annotationViews.
/// This must be called if parameters that affect relative x,y of annotations changed.
/// <ul>
///   <li>
///     if azimuths on annotations are calculated(This can change relative horizontal positions of annotations)
///   </li>
///   <li>
///     when adjustVerticalOffsetParameters is called because that can affect relative vertical positions of annotations
///   </li>
/// </ul>
/// Pitch/heading of the device doesn’t affect relative positions of annotationViews.
- (void)stackAnnotationViews;
/// Resets temporary stacking fields. This must be called before stacking and before layout.
- (void)resetStackParameters;
@end

@class CLLocationManager;
@class CLHeading;

/// Class used internally by ARViewController for tracking and filtering location/heading/pitch etc.
/// ARViewController takes all these informations and stores them in ARViewController.arStatus object,
/// which is then passed to ARPresenter. Not intended for subclassing.
SWIFT_CLASS("_TtC18HDAugmentedReality17ARTrackingManager")
@interface ARTrackingManager : NSObject <CLLocationManagerDelegate>
/// Filter(Smoothing) factor for heading in range 0-1. It affects horizontal movement of annotaion views. The lower the value the bigger the smoothing.
/// Value of 1 means no smoothing, should be greater than 0. Default value is 0.05
@property (nonatomic) double headingFilterFactor;
/// Filter(Smoothing) factor for pitch in range 0-1. It affects vertical movement of annotaion views. The lower the value the bigger the smoothing.
/// Value of 1 means no smoothing, should be greater than 0. Default value is 0.05
@property (nonatomic) double pitchFilterFactor;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
/// Starts location and motion manager
/// \param notifyFailure If true, will call arTrackingManager:didFailToFindLocationAfter: if location is not found.
///
- (void)startTrackingWithNotifyLocationFailure:(BOOL)notifyLocationFailure;
/// Stops location and motion manager
- (void)stopTracking;
/// Stops all timers and resets all data.
- (void)resetAllTrackingData;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didUpdateHeading:(CLHeading * _Nonnull)newHeading;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didUpdateLocations:(NSArray<CLLocation *> * _Nonnull)locations;
@end

@class UIImage;
@class NSBundle;
@protocol UIViewControllerTransitionCoordinator;
@class NSError;

/// Augmented reality view controller.
/// How to use:
/// <ol>
///   <li>
///     Initialize controller and set datasource
///   </li>
///   <li>
///     Use setAnnotations method to set annotations
///   </li>
///   <li>
///     Present controller modally
///   </li>
///   <li>
///     Implement ARDataSource to provide annotation views in your data source
///   </li>
/// </ol>
/// https://github.com/DanijelHuis/HDAugmentedReality.git
SWIFT_CLASS("_TtC18HDAugmentedReality16ARViewController")
@interface ARViewController : UIViewController
/// Data source - source of annotation views for ARViewController/ARPresenter, implement it to provide annotation views.
@property (nonatomic, weak) id <ARDataSource> _Nullable dataSource;
/// Orientation mask for view controller. Make sure orientations are enabled in project settings also.
@property (nonatomic) UIInterfaceOrientationMask interfaceOrientationMask;
/// Class for tracking location/heading/pitch. Use it to set properties like reloadDistanceFilter, userDistanceFilter etc.
@property (nonatomic, readonly, strong) ARTrackingManager * _Nonnull trackingManager;
/// Image for close button. If not set, default one is used.
@property (nonatomic, strong) UIImage * _Nullable closeButtonImage;
/// Called every 5 seconds after location tracking is started but failed to deliver location. It is also called when tracking has just started with timeElapsed = 0.
/// The timer is restarted when app comes from background or on didAppear.
@property (nonatomic, copy) void (^ _Nullable onDidFailToFindLocation)(NSTimeInterval, BOOL);
/// Presenter instance. It is responsible for creation and layout of annotation views. Subclass and provide your own implementation if needed. Always set it before anything else is set on this controller.
@property (nonatomic, strong) ARPresenter * _Null_unspecified presenter;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
- (void)viewWillAppear:(BOOL)animated;
- (void)viewDidAppear:(BOOL)animated;
- (void)viewDidDisappear:(BOOL)animated;
- (void)viewDidLayoutSubviews;
/// Sets annotations and calls reload on presenter
- (void)setAnnotations:(NSArray<ARAnnotation *> * _Nonnull)annotations;
- (NSArray<ARAnnotation *> * _Nonnull)getAnnotations SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) BOOL shouldAutorotate;
@property (nonatomic, readonly) UIInterfaceOrientationMask supportedInterfaceOrientations;
- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
@property (nonatomic, readonly) BOOL prefersStatusBarHidden;
/// Checks if back video device is available.
+ (NSError * _Nullable)isAllHardwareAvailable SWIFT_WARN_UNUSED_RESULT;
@end

@class AVCaptureDevice;

/// UIView with video preview layer. Call startRunning/stopRunning to start/stop capture session.
/// Use createCaptureSession to check if cameraView can be initialized correctly.
SWIFT_CLASS("_TtC18HDAugmentedReality10CameraView")
@interface CameraView : UIView
/// Media type, set it before adding to superview.
@property (nonatomic, copy) NSString * _Nonnull mediaType;
/// Capture device position, set it before adding to superview.
@property (nonatomic) AVCaptureDevicePosition devicePosition;
/// Video gravitry for videoPreviewLayer, set it before adding to superview.
@property (nonatomic, copy) NSString * _Nonnull videoGravity;
- (void)didMoveToSuperview;
- (void)layoutSubviews;
/// Starts running capture session
- (void)startRunning;
/// Stops running capture session
- (void)stopRunning;
- (void)setVideoOrientation:(UIInterfaceOrientation)orientation;
- (AVCaptureDevice * _Nullable)inputDevice SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class MKMapView;

/// Called from ARViewController for debugging purposes
SWIFT_CLASS("_TtC18HDAugmentedReality22DebugMapViewController")
@interface DebugMapViewController : UIViewController <MKMapViewDelegate, CLLocationManagerDelegate>
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)viewDidLoad;
- (void)viewDidAppear:(BOOL)animated;
- (void)viewDidDisappear:(BOOL)animated;
- (void)addAnnotations:(NSArray<ARAnnotation *> * _Nonnull)annotations;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didUpdateHeading:(CLHeading * _Nonnull)newHeading;
- (void)mapView:(MKMapView * _Nonnull)mapView regionWillChangeAnimated:(BOOL)animated;
- (void)mapView:(MKMapView * _Nonnull)mapView regionDidChangeAnimated:(BOOL)animated;
@end

#pragma clang diagnostic pop
